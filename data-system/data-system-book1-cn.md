
# Document & Code

- book
  - [Designing Data-Intensive Applications](https://www.amazon.com/dp/1449373321)
  - [数据密集型应用系统设计](https://www.amazon.cn/dp/B07HGH8153)

- link
  - [GitHub/ept/ddia-references](https://github.com/ept/ddia-references)

---

# 目录

- __一. 可靠, 可拓展与可维护的应用系统__
  - __认识数据系统__
  - __可靠性__
    - 硬件故障
    - 软件错误
    - 人为失误
    - 可靠性的重要性
  - __可拓展性__
    - 描述负载
    - 描述性能
    - 应对负载增加的方法
  - __可维护性__
    - 可运维性: 运维更轻松
    - 简单性: 简化复杂度
    - 可演化性: 易于改变
- __二. 数据模型与查询语言__
  - __关系模型与文档模型__
    - NoSQL 的诞生
    - 对象 - 关系不匹配
    - 多对一与多对多的关系
    - 文档数据库是否再重演历史?
      - 网络模型
      - 关系模型
      - 文档数据库的比较
    - 关系数据库与文档数据库现状
      - 哪种数据模型的应用代码更简单?
      - 文档模型中的模式灵活性
      - 查询的数据局部性
      - 文档数据库与关系数据库的融合
  - __数据查询语言__
    - Web 上的声明式查询
    - MapReduce 查询
  - __图状数据模型__
    - 属性图
    - Cypher 查询语言
    - SQL 中的图查询
    - 三元存储与 SPARQL
      - 语义网
      - RDF 数据模型
      - SPARQL 查询语言
    - Datalog 基础
- __三. 数据存储与检索__
  - __数据库核心: 数据结构__
    - 哈希索引
    - SSTables 和 LSM-Tree
      - 构建和维护 SSTables
      - 从 SSTables 到 LSM-Tree
      - 性能优化
    - B-trees
      - 使 B-tree 可靠
      - 优化 B-tree
    - 对比 B-Tree 和 LSM-Tree
      - LSM-Tree 的优点
      - LSM-Tree 的缺点
    - 其他索引结构
      - 在索引中存储值
      - 多列索引
      - 全文搜索和模糊索引
      - 在内存中保存所有内容
  - __事务处理与分析处理__
    - 数据仓库
      - OLTP 数据库和数据仓库之间的差异
    - 星型与雪花型分析模式
  - __列式存储__
    - 列压缩
      - 内存宽带和矢量化处理
    - 列存储中的排序
      - 几种不同的排序
    - 列存储的写操作
    - 聚合: 数据立方体与物化视图
- __四. 数据编码与演化__
  - __数据编码格式__
    - 语言特定的格式
    - JSON, XML 与二进制变体
      - 二进制编码
    - Thrift 与 Protocol Buffers
      - 字段标签和模式演化
      - 数据类型和模式演化
    - AVRO
      - 写模式与读模式
      - 模式演化规则
      - 那么 write 模式又是什么?
      - 动态生成的模式
      - 代码生成和动态类型语言
    - 模式的优点
  - __数据流模式__
    - 基于数据库的数据流
      - 不同的时间写入不同的值
      - 归档存储
    - 基于服务的数据流: REST 和 RPC
      - 网络服务
      - 远程过程调用 (RPC) 的问题
      - RPC 的发展方向
      - RPC 的数据编码和演化
    - 基于消息传递的数据流
      - 消息代理
      - 分布式 Actor 框架
- __五. 数据复制__
  - __主节点与从节点__
    - 同步复制与异步复制
    - 配置新的从节点
    - 处理节点失效
      - 从节点失效: 追赶式恢复
      - 主节点失效: 节点切换
    - 复制日志的实现
      - 基于语句的复制
      - 基于预写日志 (WAL) 的传输
      - 基于行的逻辑日志复制
      - 基于触发器的复制
  - __复制滞后问题__
    - 读自己的写
    - 单调读
    - 前缀一致读
    - 复制之后的解决方案
  - __多主节点复制__
    - 适用场景
      - 多数据中心
      - 离线客户端操作
      - 协作编辑
    - 处理写冲突
      - 同步与异步冲突检测
      - 避免冲突
      - 收敛于一致状态
      - 自定义冲突解决逻辑
      - 什么式冲突?
    - 拓扑结构
  - __无主节点复制__
    - 节点失效时写入数据库
      - 读修复与反熵
      - 读写 quorum
    - Quorum 一致性的局限性
      - 监控旧值
      - 宽松的 quorum 与数据回传
      - 多数据中心操作
    - 检测并发写
      - 最后写入顺利 (丢弃并发写入)
      - Happens-before 关系和并发
      - 确定前后关系
      - 合并同时写入的值
      - 版本矢量
- __六. 数据分区__
  - __数据分区与数据复制__
  - __键 - 值数据的分区__
    - 基于关键字区间分区
    - 基于关键字哈希值分区
    - 负载倾斜与热点
  - __分区与二级索引__
    - 基于文档分区的二级索引
    - 基于词条分区的二级索引
  - __分区再平衡__
    - 动态再平衡的策略
      - 为什么不用取模?
      - 固定数量的分区
      - 动态分区
      - 按节点比例分区
    - 自动与手动再平衡操作
  - __请求路由__
    - 并行查询执行
- __七. 事务__
  - __深入理解事务__
    - ACID 的含义
      - 原子性
      - 一致性
      - 隔离性
      - 持久性
    - 单对象与多对象事务操作
      - 单对象写入
      - 多对象事务的必要性
      - 处理错误与中止
  - __弱隔离级别__
    - 读 - 提交
      - 防止脏读
      - 实现读 - 提交
    - 快照级别隔离与可重复读
      - 实现快照级别隔离
      - 一致性快照的可见性规则
      - 索引与快照级别隔离
      - 可重复读与命名混淆
    - 防止更新丢失
      - 原子写操作
      - 显式加锁
      - 自动检测更新丢失
      - 原子比较和设置
      - 冲突解决与复制
    - 写倾斜与幻读
      - 定义写倾斜
      - 更多写倾斜的例子
      - 为何产生写倾斜
      - 实体化冲突
  - __串行化__
    - 实际串行执行
      - 采用存储过程封装事务
      - 存储过程的优缺点
      - 分区
      - 串行执行小结
    - 两阶段加锁
      - 实现两阶段加锁
      - 两阶段加锁的性能
      - 谓词锁
      - 索引区间锁
    - 可串行化的快照隔离
      - 悲观与乐观的并发控制
      - 基于过期的条件做决定
      - 检测是否读取了过期的 MVCC 对象
      - 检测写是否影响了之前的读
      - 可串行化快照隔离的性能
- __八. 分布式系统的挑战__
  - __故障与部分失效__
    - 云计算和超算
  - __不可靠的网络__
    - 现实中的网络故障
    - 故障检测
    - 超时与无限期的延迟
      - 网络拥塞与排队
    - 同步与异步网络
      - 网络延迟是否可预测?
  - __不可靠的时钟__
    - 单调时钟与墙上时钟
      - 墙上时钟
      - 单调时钟
    - 时钟同步与准确性
    - 依赖同步的时钟
      - 时间戳与事件顺序
      - 时钟的置信区间
      - 全局快照的同步时钟
    - 进程暂停
      - 相应时间保证
      - 调整垃圾回收的影响
  - __知识, 真相与谎言__
    - 真相由多数决定
      - 主节点与锁
      - Fencing 令牌
    - 拜占庭故障
      - 弱的谎言形式
    - 理论系统模型与现实
      - 算法的正确性
      - 安全与活性
      - 将系统模型映射到现实世界
- __九. 一致性与共识__
  - __一致性保证__
  - __可线性化__
    - 如何达到线性化?
    - 线性化的依赖条件
      - 加锁与主节点选举
      - 约束与唯一性保证
      - 跨通道的时间依赖
    - 实现线性化系统
      - 线性化与 quorum
    - 线性化的代价
      - CAP 理论
      - 可线性化与网络延迟
  - __顺序保证__
    - 顺序与因果关系
      - 因果顺序并非全序
      - 可线性化强于因果一致性
      - 捕获因果依赖关系
    - 序列号排序
      - 非因果序列发生器
      - Lamport 时间戳
      - 时间戳排序依然不够
    - 全序关系广播
      - 使用全序关系广播
      - 采用全序关系广播实现线性化存储
      - 采用线性化存储实现全序关系广播
  - __分布式事务与共识__
    - 原子提交与两阶段提交
      - 从单节点到分布式的原子提交
      - 两阶段提交
      - 系统的承诺
      - 协调者发生故障
      - 三阶段提交
    - 实践中的分布式事务
      - Exactly-once 消息处理
      - XA 交易
      - 停顿时仍持有锁
      - 从协调者故障中恢复
      - 分布式事务的限制
    - 支持容错的共识
      - 共识算法与全序广播
      - 主从复制与共识
      - Epoch 和 Quorum
      - 共识的局限性
    - 成员与协调服务
      - 节点任务分配
      - 服务发现
      - 成员服务
- __十. 批处理系统__
  - __使用 UNIX 工具进行批处理__
  - __MapReduce 与分布式文件系统__
  - __超越 MapReduce__
- __十一. 流处理系统__
  - __发送事件流__
  - __数据库与流__
  - __流处理__
- __十二. 数据系统的未来__
  - __数据集成__
  - __分拆数据库__
  - __端到端的正确性__
  - __做正确的事情__
  